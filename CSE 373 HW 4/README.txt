agrigore 1229767
rigodiaz 1228362


1) Describe the worst-case asymptotic running times of your methods adjacentVertices, edgeCost, and shortestPath. In your answers, use |E| for the number of edges and |V| for the number of vertices. Explain and justify your answers.
    adjecentVertices runs at O(|E|) if |E| is the number of outgoing edges that the passed in Vertex v contains. It is possible that this Vertex contains all the outgoing edges of the graph so O(|E|) stands for all edges.

    edgeCost runs at O(|E|) + O(|E|) + O(|E|) = O(|E|). The call to adjacentVertices to check each adjacent vertex requires O(|E|) runtime. The "copy-in" of each edge of Vertex a requires O(|E|) runtime. Lastly, it takes O(|E|)runtime to check each edge of the adjecent vertices to obtain the edge cost of Vertex b. 

    shortestPath runs at O(|V|) + O(|V||E|log|V|) = O(|V||E|log|V|)
    The creation of new VertexInfos for each vertex in the graph requires O(|V|) runtime. The while loop requires access to each vertex. The slowest runtime for this is O(|V|). The for loop within the while loop requires access to all vertexes adjecent to the current vertex. The slowest runtime for this case is if all the edges in the graph are sourced from the current vertex. Therefore this runs at O(|E|). Lastly, adding a new value into the priority queue would require O(log|V|) in the worst case scenario.

2) Describe how your code ensures the graph abstraction is protected. If your code makes extra copies of objects for (only) this purpose, explain why. If not, explain why it is not necessary.
	Our code ensures that the graph abstraction is protected by implemented "copy-in" and "copy-out" practices and immutability over all parameters passed in to AND returned from the code. All parameters passed into MyGraph are copied to a new variable so that the parameter does not have direct reference to the internals of the class. This implementes the "copy-in" practice of abstraction. Similarly, all variables returned from a MyGraph method is initially copied to a new variable which is then returned. This implements the "copy-out" practice of abstraction. This restricts clients from accessing the internal fields and methods of the MyGraph class. Furthermore, the code has many test cases that maintain the structure of the graph. When attempts to store faulty data is made by clients (e.g. negative weights, calls to vertices that don't exist, edge creations to vertices that don't exist) Illegal Arguments are thrown to stop the code from running/implementing illegal data. 

3) Describe how you tested your code.
	The testing of the code was done at multiple different levels. Initially, the completion of each method required testing to ensure that the method successfully executed the required task. For example, after completion of the constructor, we tested its functionality by sending in Collections of edges and vertices and reading the method's response. Edge cases such as negative weights and invalid vertices were testing at this time to ensure that the constructor didn't allow any illegal arguments from the client. The vertices() method was also tested after implementing. We passed in a variety of Collections of Vertices to ensure that the vertices() method returned the correct vertices and no illegal arguments from the client were allowed. The same level of testing went into the edges() method, where we ensured the correct edges from a variety of Collections passed in were returned successfully. Next, adjacentVertices was tested by sending in a variety of Vertices and reading the method's responses. Illegal arguments (non-existent vertices) were sent in as a test and all IllegalArugmentExceptions were successful. edgeCost was tested in a similar fashion. We tested all edge cases  (non-existent vertices passed in as parameters) and verified the correct responses from the method. If either Vertex a or b did not exist in myGraph, an IllegalArgumentException was successfully thrown. If the edge existed between the vertices, the correct edge cost was returned. If the edge did not exist the method successfully returned -1. Lastly, shortestPath was tested by ensuring illegal arguments cause an Exception and all returns were valid and correct. This was done step-by-step because this method was hairier than the rest. First we tested the VertexInfo class we created to ensure that the fields of this class maintained correct. Next we created a Priority Queue to store the paths taken by the iterative while loop. We tested this with .txt files containing a small amount of edges and vertices. Once we verified that the Priority Queue was successfully built with a small amount of nodes, we tested it again with larger .txt files. Once the Priority Queue was verified to be functioning, we tested the overall output of shortestPath with a variety of cases. We ensured the method ran successfully given illegal arguments and a variety of different path calls across a large graph. 
    
4) If you worked with a partner, describe how you worked together. If you divided up the tasks, explain how you did so. If you worked on parts together, describe the actual process. Discuss how much time you worked together and how you spent that time (planning, coding, testing, ...). Be sure to describe at least one good thing and one bad thing about the process of working with a partner.
	The majority of the work was shared except for a few specific tasks that were divided up. We built and tested all of the methods in MyGraph together. Testing and debugging was done together. We talked our way through how we thought each method was to be done. Then, once we came to a conclusion, one of us began writing the method. If we ran into a problem, we would stop and discuss how to solve it. We would also trade on and off the actual writing/typing. 
	The write up was done together as well. Overall, we spent about 10 hours on this lab. One good thing about working with a partner is that it is easier to brainstorm techniques to tackling specific problems. It is easier to come up with new ideas when two minds are working on it at once. One bad thing about working with a partner is scheduling. When both of us have heavy work loads from other classes, it is difficult to find time to work on CSE together. 
    
5) If you did any above-and-beyond, describe what you did.



